# =========================
# rounding.tcl  (portable)
# =========================
#
# This file has been generated by ChatGPT.
#
# Strategy 1: Grid-first (choose SMALLEST grid g >= 5%·|x|)
# Strategy 2: Largest-error (choose candidate with max abs error < 5%)
#
# Scale: 3rd-significant-digit unit u = 10^(floor(log10(|x|)) - 2)
# Steps default to cover 1% in [1u,10u): {1 2 2.5 5 10}
#
# Public API (namespace ::rounding):
#   rounding::set_steps {1 2 2.5 5 10}
#   rounding::round_grid_first_ge_1pct  x
#   rounding::round_largest_error_under_1pct  x
#   rounding::chosen_grid_gridfirst     x    ;# return chosen grid (g)
#   rounding::chosen_grid_largesterr    x    ;# return chosen grid (g)
#   rounding::report x strategy         ;# strategy in {gridfirst largesterr}
#
# All procs avoid lsort/lassign/dict for maximum tool portability.

namespace eval rounding {
  variable STEPS {1.0 2.5 5.0 10.0}
  variable PERC 0.025
}

proc rounding::set_steps {steps perc} {
  # Basic validation (optional)
  if {[llength $steps] == 0} {
    error "rounding::set_steps: step list must not be empty"
  }
  # Ensure all convertible to double
  foreach s $steps {
    if {[catch {expr {double($s)}}]} {
      error "rounding::set_steps: non-numeric step '$s'"
    }
  }
  variable STEPS
  set STEPS $steps
  variable PERC
  set PERC $perc
}

# ---- math helpers (no lsort/lassign) ----
proc rounding::_abs {x} { expr {abs($x)} }

proc rounding::_unit3sf {x} {
  # u = 10^(floor(log10(|x|)) - 2) ; log10 via ln
  set ax [expr {abs($x)}]
  if {$ax == 0.0} { return 0.0 }
  return [expr {pow(10.0, floor(log($ax)/log(10.0)) - 2)}]
}

proc rounding::_round_half_up_to_grid {x g} {
  # Half-up rounding to nearest multiple of g
  set ax [expr {abs($x)}]
  set y  [expr {floor($ax / $g + 0.5) * $g}]
  if {$x < 0} { set y [expr {- $y}] }
  return $y
}

proc rounding::_pct {part total} {
  if {$total == 0.0} { return 0.0 }
  return [expr {100.0 * $part / $total}]
}

# -------------------------------
# Strategy 1: Grid-first ≥ 1%
# -------------------------------
proc rounding::round_grid_first {x} {
  if {$x == 0.0} { return 0.0 }
  variable STEPS
  variable PERC

  set ax     [expr {abs($x)}]
  set u      [rounding::_unit3sf $x]
  set tol    [expr {$PERC * $ax}]
  set eps    [expr {1e-12 * ($ax > 1.0 ? $ax : 1.0)}]

  # Find smallest grid >= 1%·|x|; track also smallest grid overall
  set chosen_g ""
  set best_over 1e300
  set smallest_g ""
  set best_small 1e300

  foreach s $STEPS {
    set g [expr {$s * $u}]
    if {$g < $best_small} { set best_small $g; set smallest_g $g }
    if {($g >= $tol) && ($g < $best_over)} {
      set best_over $g
      set chosen_g  $g
    }
  }
  if {$chosen_g eq ""} {
    # Fallback (shouldn’t happen with steps including 10)
    set chosen_g $smallest_g
  }

  set y   [rounding::_round_half_up_to_grid $x $chosen_g]
  set err [expr {abs($y - $x)}]
  if { !($err <= $tol + $eps) } {
    error "round_grid_first_ge_1pct: Error $err exceeds 1% of |x| ($tol)"
  }
  return $y
}

# Return just the chosen grid for Strategy 1
proc rounding::chosen_grid_gridfirst {x} {
  if {$x == 0.0} { return 0.0 }
  variable STEPS
  variable PERC

  set ax     [expr {abs($x)}]
  set u      [rounding::_unit3sf $x]
  set tol    [expr {$PERC * $ax}]

  set chosen_g ""
  set best_over 1e300
  set smallest_g ""
  set best_small 1e300

  foreach s $STEPS {
    set g [expr {$s * $u}]
    if {$g < $best_small} { set best_small $g; set smallest_g $g }
    if {($g >= $tol) && ($g < $best_over)} {
      set best_over $g
      set chosen_g  $g
    }
  }
  if {$chosen_g eq ""} { set chosen_g $smallest_g }
  return $chosen_g
}

# ------------------------------------------
# Strategy 2: Largest error strictly < 1%
# ------------------------------------------
proc rounding::round_largest_error {x} {
  if {$x == 0.0} { return 0.0 }
  variable STEPS
  variable PERC

  set ax     [expr {abs($x)}]
  set u      [rounding::_unit3sf $x]
  set tol    [expr {$PERC * $ax}]
  set eps    [expr {1e-12 * ($ax > 1.0 ? $ax : 1.0)}]

  # Track best under-1% by largest error; tie: larger grid, then larger |y|
  set have_under 0
  set best_err_under -1.0
  set best_g_under 0.0
  set best_y_under 0.0

  # Nearest overall fallback (smallest error; tie: smaller grid)
  set have_any 0
  set best_err_any 1e300
  set best_g_any 0.0
  set best_y_any 0.0

  foreach s $STEPS {
    set g [expr {$s * $u}]
    set y [rounding::_round_half_up_to_grid $x $g]
    set err [expr {abs($y - $x)}]

    if {(!$have_any) || ($err < $best_err_any) || ($err == $best_err_any && $g < $best_g_any)} {
      set have_any 1
      set best_err_any $err
      set best_g_any   $g
      set best_y_any   $y
    }

    if {$err < $tol} {
      if {(!$have_under)
          || ($err > $best_err_under)
          || ($err == $best_err_under && $g > $best_g_under)
          || ($err == $best_err_under && $g == $best_g_under && abs($y) > abs($best_y_under))} {
        set have_under 1
        set best_err_under $err
        set best_g_under   $g
        set best_y_under   $y
      }
    }
  }

  if {$have_under} {
    set y   $best_y_under
    set g   $best_g_under
    set err $best_err_under
  } else {
    set y   $best_y_any
    set g   $best_g_any
    set err $best_err_any
  }

  if { !($err <= $tol + $eps) } {
    error "round_largest_error_under_1pct: Error $err exceeds 1% of |x| ($tol)"
  }
  return $y
}

# Return just the chosen grid for Strategy 2
proc rounding::chosen_grid_largesterr {x} {
  if {$x == 0.0} { return 0.0 }
  variable STEPS
  variable PERC

  set ax     [expr {abs($x)}]
  set u      [rounding::_unit3sf $x]
  set tol    [expr {$PERC * $ax}]

  set have_under 0
  set best_err_under -1.0
  set best_g_under 0.0
  set best_y_under 0.0

  set have_any 0
  set best_err_any 1e300
  set best_g_any 0.0
  set best_y_any 0.0

  foreach s $STEPS {
    set g [expr {$s * $u}]
    set y [rounding::_round_half_up_to_grid $x $g]
    set err [expr {abs($y - $x)}]

    if {(!$have_any) || ($err < $best_err_any) || ($err == $best_err_any && $g < $best_g_any)} {
      set have_any 1
      set best_err_any $err
      set best_g_any   $g
      set best_y_any   $y
    }

    if {$err < $tol} {
      if {(!$have_under)
          || ($err > $best_err_under)
          || ($err == $best_err_under && $g > $best_g_under)
          || ($err == $best_err_under && $g == $best_g_under && abs($y) > abs($best_y_under))} {
        set have_under 1
        set best_err_under $err
        set best_g_under   $g
        set best_y_under   $y
      }
    }
  }

  if {$have_under} { return $best_g_under }
  return $best_g_any
}

# -------------------------
# Human-readable reporting
# -------------------------
# Usage: rounding::report 1235.32 gridfirst
#     or rounding::report 1235.32 largesterr
proc rounding::report {x strategy} {
  if {$x == 0.0} {
    puts "x=0 → 0 (trivial)"
    return
  }
  set ax     [expr {abs($x)}]
  set u      [rounding::_unit3sf $x]
  set tol    [expr {$PERC * $ax}]

  if {$strategy eq "gridfirst"} {
    set y [rounding::round_grid_first_ge_1pct $x]
    set g [rounding::chosen_grid_gridfirst $x]
  } elseif {$strategy eq "largesterr"} {
    set y [rounding::round_largest_error_under_1pct $x]
    set g [rounding::chosen_grid_largesterr $x]
  } else {
    error "rounding::report: unknown strategy '$strategy' (use gridfirst|largesterr)"
  }

  set err [expr {abs($y - $x)}]
  set p   [rounding::_pct $err $ax]

  puts [format "x=%g  u=%g  1%%=%.6g  grid=%g  y=%g  |err|=%g (%.6f%%%%)" \
        $x $u $tol $g $y $err $p]
}

# =========================
# (Optional) quick self-test
# Uncomment to try:
# foreach v {1235.32 643.57 134.34 35.544 23.455} {
#   rounding::report $v gridfirst
#   rounding::report $v largesterr
# }
# =========================

